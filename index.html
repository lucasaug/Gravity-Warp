<!DOCTYPE html>
<html>
    <head>
        <title>Jogo</title>
        <script type="text/javascript">
            
            // Vector class with the following operations implemented:

            // - addition
            // - subtraction
            // - multiplication
            // - division

            // all these functions have two implementations: one that changes
            // the vector in which the operation is applied, and other that
            // returns the a new vector which is the result of the operation

            // also implements getters and setters for angle and length
            // has functions for rotation, getting the unit length vector,
            // getting x and y component vectors of another vector,
            // dot products and projection onto another vector

            function Vector(x,y){
                this.x = x;
                this.y = y;

                this.addTo = function(vec){
                    this.x += vec.x;
                    this.y += vec.y;
                };

                this.subtractFrom = function(vec){
                    this.x -= vec.x;
                    this.y -= vec.y;
                };

                this.multiplyBy = function(scalar){
                    this.x *= scalar;
                    this.y *= scalar;
                };

                this.divideBy = function(scalar){
                    this.multiplyBy(1/scalar);
                };

                this.rotateBy = function(angle){
                    var currentAng = this.getAngle();
                    this.setAngle(currentAng + angle);
                };

                this.add = function(vec){
                    return new Vector(this.x + vec.x, this.y + vec.y);
                };

                this.subtract = function(vec){
                    return new Vector(this.x - vec.x, this.y - vec.y);
                };

                this.multiply = function(scalar){
                    return new Vector(this.x * scalar, this.y * scalar);
                };

                this.divide = function(scalar){
                    return this.multiply(1/scalar);
                };

                this.rotate = function(angle){
                    var result = this;
                    result.rotateBy(angle);
                    return result;
                };

                this.setAngle = function(angle) {
                    var length = this.getLength();
                    this.x = Math.cos(angle) * length;
                    this.y = Math.sin(angle) * length;
                };

                this.getAngle = function() {
                    return Math.atan2(this.y, this.x);
                };

                this.setLength = function(length) {
                    var angle = this.getAngle();
                    this.x = Math.cos(angle) * length;
                    this.y = Math.sin(angle) * length;
                };

                this.getLength = function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                };

                this.getUnit = function() {
                    return this.divide(this.getLength());
                };

                this.dot = function(vector){
                    return this.x * vector.x + this.y * vector.y;
                };

                this.projectionOnto = function(vector){
                    var result = this.dot(vector)/vector.getLength();
                    return vector.getUnit().multiply(result);
                };

                this.xComponent = function(){
                    return new Vector(this.x,0);
                };

                this.yComponent = function(){
                    return new Vector(0,this.y);
                };
            };

            // Game class which manages gamestates
            function Game(canvas,width){
                this.width                = width;
                this.height               = width;
                // the x and y position of the field is calculated so it
                // never surpasses the canvas, even when rotated.
                this.x                    = Math.floor((width * (1 - Math.SQRT2))/(-2 * Math.SQRT2));
                this.y                    = this.x;
                this.currentGameStateName = null;

                // buffer canvas and context, we pass these to the
                // gamestates
                this.bCanvas              = null;
                this.ctx                  = null;

                // last frame render timestamp
                this.lastRender   = 0;
                // constant for determining framerate, milliseconds between each frame
                this.frameUpdate  = 15;

                // list of existing gamestates
                // a gamestate must implement the following methods:
                // onEnter, update and onExit
                // (pretty self explanatory)
                this.gameStates           = {};

                this.startGame = function(){
                    // define the buffers
                    this.bCanvas = document.createElement("canvas");
                    this.bCanvas.setAttribute("width", canvas.width);
                    this.bCanvas.setAttribute("height", canvas.height);
                    this.ctx = this.bCanvas.getContext('2d');

                    // here we create the gamestates
                    this.gameStates = {
                        "menu"     : new MenuGameState(canvas, this.x, this.y, this.width, this.height, this.bCanvas,
                                                       this.ctx),
                        "playing"  : new PlayingGameState(canvas, this.x, this.y, this.width, this.height, this.bCanvas,
                                                          this.ctx),
                        "gameover" : null
                    };

                    // and now define the first gamestate (menu) and start game
                    this.currentGameStateName = "menu";
                    this.gameStates[this.currentGameStateName].onEnter();
                    this.update();
                }

                this.update = function(){
                    // calculates if it's been enough time for a new frame to be rendered
                    // if it is, calls update on the gamestate
                    var elapsed = Date.now() - this.lastRender;
                    if(elapsed > this.frameUpdate){
                        this.lastRender = Date.now();
                        var shouldStop = this.gameStates[this.currentGameStateName].update();
                        if(shouldStop){
                            if(this.currentGameStateName === "menu" || this.currentGameStateName === "gameover")
                                this.changeGameState("playing");
                            else if(this.currentGameStateName === "playing")
                                this.changeGameState("gameover");
                        }
                    }
                    requestAnimationFrame(this.update.bind(this));
                };

                this.changeGameState = function(newGSName){
                    this.gameStates[this.currentGameStateName].onExit();
                    this.currentGameStateName = newGSName;
                    this.gameStates[this.currentGameStateName].onEnter();
                }
            };

            // Initial GameState, draws game menu
            function MenuGameState(canvas, x, y, width, height, bCanvas, ctx){
                this.width     = width  - 2*x;
                this.height    = height - 2*y;
                this.x         = x;
                this.y         = y;
                this.canvas    = canvas;
                // this is the buffer canvas for drawing images
                // for performance improvements
                this.bCanvas   = bCanvas;
                // this context refers to the buffer's context
                this.ctx       = ctx;
                this.angle     = 0;
                this.rotSpd    = Math.PI/720;
                this.bgAlpha   = 0.;
                this.alphaStep = 0.01;
                this.maxAlpha  = 0.6;
                this.startGame = false;

                this.detectInput = function(){};

                this.onEnter = function(){
                    var self = this;

                    // redefine function to avoid "this" issues
                    this.detectInput = function(e){
                        if(e.keyCode === 13)
                            self.startGame = true;
                    };

                    // sets event handlers
                    window.onkeydown = this.detectInput;
                };

                this.update = function(){
                    // draws buffer canvas into actual canvas
                    this.canvas.getContext('2d').drawImage(this.bCanvas,0,0);

                    this.ctx.save();
                    this.ctx.fillStyle = "#300FC0";
                    this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
                    this.ctx.translate(this.canvas.width/2, this.canvas.height/2);
                    this.ctx.rotate(-1*this.angle + Math.PI/2);
                    this.ctx.translate(-1*this.canvas.width/2, -1*this.canvas.height/2);
                    this.ctx.fillStyle = "#000040";
                    this.ctx.fillRect(this.x,this.y,this.canvas.width-2*this.x,this.canvas.height-2*this.y);

                    // draws a nice background
                    this.ctx.beginPath();
                    for(var i = this.x + 10; i < this.width + this.x; i += 10){
                        this.ctx.moveTo(i,this.y);
                        this.ctx.lineTo(i,this.height + this.y);
                    }
                    for(var i = this.y + 10; i < this.height + this.y; i += 10){
                        this.ctx.moveTo(this.x, i);
                        this.ctx.lineTo(this.width + this.x, i);
                    }
                    this.ctx.stroke();

                    this.ctx.restore();

                    // white fading-in background
                    this.ctx.fillStyle = "rgba(255, 255, 255, " + this.bgAlpha * this.maxAlpha + ")";
                    this.ctx.fillRect(this.canvas.width * 0.1, this.canvas.height * 0.1, 
                                      this.canvas.width * 0.8,  this.canvas.height * 0.8);

                    if(this.bgAlpha < 1){
                        this.bgAlpha += this.alphaStep;
                    }

                    // writes game instructions
                    var title = "Gravity Warp",
                        desc  = [
                            "Control the cube using the arrow keys or",
                            "the wasd keys.",
                            "Avoid the obstacles in the way, trying to",
                            "get as many coins as possible.",
                            "Your score will be calculated based on the",
                            "seconds survived as well as the number",
                            "of coins caught"
                        ],
                        startTxt = "Press Enter/Return to start";

                    // fonts and line spacing are determined by the total canvas width
                    // and height
                    this.ctx.font = this.canvas.width * 0.08 +"px Garamond";
                    this.ctx.fillStyle = "rgba(0, 0, 0, " + this.bgAlpha + ")";
                    this.ctx.fillText(title, this.canvas.width * 0.25, this.canvas.height * 0.22 + 20);
                    this.ctx.font = this.canvas.width * 0.03 +"px Garamond";
                    for(var i = 1; i < desc.length + 1; i++)
                        this.ctx.fillText(desc[i-1],  this.canvas.width * 0.18, 
                                    this.canvas.height * 0.2 + i * (0.05 * this.canvas.width) + (0.13 * this.canvas.width));

                    this.ctx.font = this.canvas.width * 0.05 +"px Garamond";
                    this.ctx.fillStyle = "rgba(30, 0, 60, " + this.bgAlpha + ")";
                    this.ctx.fillText(startTxt, this.canvas.width * 0.2, this.canvas.height * 0.8);

                    this.angle += this.rotSpd;

                    // if a key was pressed, the game should start
                    if(this.startGame)
                        return true;
                    else
                        return false;
                };

                this.onExit = function(){
                    // resets the game start attribute and alpha
                    this.startGame = false;
                    this.bgAlpha = 0.;

                    window.removeEventListener("keyup", this.detectInput);
                };
            }

            // Gamestate for actual game running
            function PlayingGameState(canvas, x, y, width, height, bCanvas, ctx){
                // width and height are relative to the playing field, not the whole canvas
                this.width        = Math.round(width  - 2*x);
                this.height       = Math.round(height - 2*y);
                // field's offset to the canvas
                this.x            = x;
                this.y            = y;
                // sets a place for the player object
                this.player       = null;
                this.playerSize   = Math.round(canvas.width*30/600);
                // pool of obstacle objects
                this.obstaclePool = new ObstaclePool();
                this.canvas       = canvas;
                // this is the canvas which will hold the background grid image
                // and game field, we do this to get some performance boost
                this.backGrid     = null;
                // this is the buffer canvas for drawing images
                // for performance improvements
                this.bCanvas   = bCanvas;
                // this context refers to the buffer's context
                this.ctx       = ctx;
                // flags for detecting arrow key presses (as well as wasd)
                this.leftPressed  = false;
                this.rightPressed = false;
                this.upPressed    = false;
                // distance travelled by player when walking or jumping
                this.playerSpeed  = 1;
                this.jumpSpeed    = 20;
                // gravity force
                this.gravity      = new Vector(0,1);
                // current directions which would make sense calling 'ground'
                this.currentGDir  = new Vector(1,1);
                // constant for speed of gravity rotation
                this.gravAngSpd   = Math.PI/720;
                // timestamp of last moment in which the field rotated
                this.lastRotation = Date.now();
                // determines in which direction the field is/was rotating
                // -1 means clockwise, 1 means the opposite
                this.rotDir       = 0;
                // the angle the field is rotating towards
                // must be given in values between -Math.PI and Math.PI
                this.nextAngle    = this.gravity.getAngle();
                // this is set to true if a rotation has been planned
                // with a setTimeout call
                this.betweenRot   = false;

                // position on the canvas, upper left edge
                this.x = x;
                this.y = y;

                this.keydown = function(e){};

                this.keyup = function(e){};

                this.onEnter = function(){
                    var self = this;

                    // redefine function to avoid "this" issues
                    this.keydown = function(e){
                        if(e.keyCode == 37 || e.keyCode == 65) self.leftPressed = true;
                        if(e.keyCode == 38 || e.keyCode == 87) self.upPressed = true;
                        if(e.keyCode == 39 || e.keyCode == 68) self.rightPressed = true;
                    };

                    this.keyup = function(e){
                        if(e.keyCode == 37 || e.keyCode == 65) self.leftPressed = false;
                        if(e.keyCode == 38 || e.keyCode == 87) self.upPressed = false;
                        if(e.keyCode == 39 || e.keyCode == 68) self.rightPressed = false;
                    };

                    // sets event handlers
                    window.onkeydown = this.keydown;
                    window.onkeyup = this.keyup;

                    // creates the background grid canvas and draws the background on it
                    this.backGrid = document.createElement("canvas");
                    this.backGrid.setAttribute("width", this.canvas.width);
                    this.backGrid.setAttribute("height", this.canvas.height);

                    var gridContext = this.backGrid.getContext("2d");
                    gridContext.fillStyle = "#000040";
                    gridContext.fillRect(this.x,this.y,this.canvas.width-2*this.x,this.canvas.height-2*this.y);
                    gridContext.beginPath();
                    for(var i = this.x + 10; i < this.width + this.x; i += 10){
                        gridContext.moveTo(i,this.y);
                        gridContext.lineTo(i,this.height + this.y);
                    }
                    for(var i = this.y + 10; i < this.height + this.y; i += 10){
                        gridContext.moveTo(this.x, i);
                        gridContext.lineTo(this.width + this.x, i);
                    }
                    gridContext.stroke();

                    // creates the player
                    this.player = new Player(
                                  ((this.width/2) | 0)-this.playerSize,
                                  this.height - this.playerSize,
                                  this.playerSize
                                );

                    // sets the four hard-coded obstacles
                    var obstSize = this.obstaclePool.obstSize;
                    this.obstaclePool.addObstacle(new Obstacle(this.x, this.y, obstSize), this.x, this.y);
                    this.obstaclePool.addObstacle(new Obstacle(this.x, this.y + this.height - obstSize,
                                                  obstSize),this.x, this.y);
                    this.obstaclePool.addObstacle(new Obstacle(this.x + this.width - obstSize, this.y, obstSize),this.x,
                                                  this.y);
                    this.obstaclePool.addObstacle(new Obstacle(this.x + this.width - obstSize,
                                                  this.y + this.height - obstSize,obstSize),this.x, this.y);

                    this.obstaclePool.spawn(this.width, this.height, this.x, this.y);
                };

                this.onExit = function(){
                    window.removeEventListener("keydown", this.keydown);
                    window.removeEventListener("keyup",   this.keyup);

                    this.obstaclePool.reset();
                };

                this.update = function(){
                    this.render(this.ctx);
                    this.step();
                };

                this.step = function(){
                    this.jumpGravStabilize();

                    // moving the player left/right and jumping
                    var movement = new Vector(0,0);
                    if(this.leftPressed)
                        movement = this.gravity.getUnit().multiply(-5 * this.playerSpeed).rotate(-1 * Math.PI/2);
                    if(this.rightPressed)
                        movement = this.gravity.getUnit().multiply(-5 * this.playerSpeed).rotate(Math.PI/2);
                    if(this.upPressed && this.playerInGround())
                        this.player.jump(this.jumpSpeed, this.gravity.getUnit());

                    this.processGravity();

                    // moves player and applies velocity
                    this.movePlayer(movement);
                    this.player.update();

                    // kills obstacles if needed
                    this.obstaclePool.update();

                    this.limitPlayerBounds();
                };

                this.render = function(ctx){
                    // draws buffer canvas into actual canvas
                    this.canvas.getContext('2d').drawImage(this.bCanvas,0,0);

                    ctx.save();
                    ctx.fillStyle = "#300FC0";
                    ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
                    // rotates the canvas properly
                    ctx.translate(this.canvas.width/2, this.canvas.height/2);
                    ctx.rotate(-1*this.gravity.getAngle() + Math.PI/2);
                    ctx.translate(-1*this.canvas.width/2, -1*this.canvas.height/2);
                    // draws the field and background grid
                    ctx.drawImage(this.backGrid, 0, 0);

                    this.player.draw(ctx);

                    // draws the obstacles
                    this.obstaclePool.render(this.ctx);

                    ctx.restore();
                };

                // keeps player inside the field
                this.limitPlayerBounds = function(){
                    var inFieldX = this.entityInFieldX(this.player);
                    if(inFieldX != 0){
                        if(inFieldX > 0){
                            this.player.position.x = this.x + this.width - this.player.size;
                        }else{
                            this.player.position.x = this.x;
                        }
                    }

                    var inFieldY = this.entityInFieldY(this.player);
                    if(inFieldY != 0){
                        if(inFieldY > 0){
                            this.player.position.y = this.y + this.height - this.player.size;
                        }else{
                            this.player.position.y = this.y;
                        }
                    }
                };

                // checks if gravity is rotating or 
                // should(n't) start rotating
                this.processGravity = function(){

                    // checks if gravity should be rotated
                    // if so, rotates it in the correct direction
                    // if not, randomly decides if should start rotating now
                    if(this.gravity.getAngle() !== this.nextAngle){
                        if(this.gravity.getAngle() < this.nextAngle){
                            this.gravity.rotateBy(this.rotDir * this.gravAngSpd);
                            // if it rotates more than needed, corrects the angle
                            if(this.gravity.getAngle() > this.nextAngle){
                                this.gravity.setAngle(this.nextAngle);
                                this.lastRotation = Date.now();
                            }
                        }else if(this.gravity.getAngle() > this.nextAngle){
                            this.gravity.rotateBy(this.rotDir * this.gravAngSpd);
                            // if it rotates more than needed, corrects the angle
                            if(this.gravity.getAngle() < this.nextAngle){
                                this.gravity.setAngle(this.nextAngle);
                                this.lastRotation = Date.now();
                            }
                        }

                    }else if(Date.now() - this.lastRotation > 5000 && !this.betweenRot){
                        this.betweenRot = true;
                        window.setTimeout( (function(){
                            this.betweenRot = false;
                            this.rotDir = 0;
                            while(!this.rotDir)
                                this.rotDir = Math.floor((Math.random()*3) - 1);
                            if(this.rotDir > 0){
                                this.nextAngle = this.gravity.getAngle() + Math.PI/2;
                                if(this.nextAngle >= Math.PI)
                                    this.nextAngle = this.nextAngle % Math.PI;
                            }else{
                                this.nextAngle = this.gravity.getAngle() - Math.PI/2;
                                if(this.nextAngle <= -1 * Math.PI)
                                    this.nextAngle = this.nextAngle % Math.PI;
                            }
                        }).bind(this) , Math.floor(Math.random() * 15) * 1000);
                    }
                };

                // regulates the jumping and collisions with the field
                // aplies gravity
                this.jumpGravStabilize = function(){
                    var vel = { x: this.player.velocity.x,
                                y: this.player.velocity.y },
                        gravDir = this.gravityDirection();

                    var groundDir = new Vector(this.playerGroundXDir(gravDir),
                                               this.playerGroundYDir(gravDir));

                    // stops jumping if player hit the ceiling
                    if(this.playerInCeiling()){
                        if((-1*gravDir.x > 0 && vel.x > 0) || (-1*gravDir.x < 0 && vel.x < 0))
                            this.player.stop({x:1});
                        if((-1*gravDir.y > 0 && vel.y > 0) || (-1*gravDir.y < 0 && vel.y < 0))
                            this.player.stop({y:1});
                    };
                    // stops gravity and velocities from acting in the ground direction if player
                    // is in ground
                    if(this.playerInGround()){
                        if(groundDir.x != 0 && groundDir.y != 0)
                            this.currentGDir = new Vector(0,0);
                        else if(groundDir.x != 0){
                            this.currentGDir.x = 0;
                            this.currentGDir.y = 1;
                        }else{
                            this.currentGDir.x = 1;
                            this.currentGDir.y = 0;
                        }

                        if((gravDir.x > 0 && vel.x > 0) || (gravDir.x < 0 && vel.x < 0))
                            this.player.stop({x:1});
                        if((gravDir.y > 0 && vel.y > 0) || (gravDir.y < 0 && vel.y < 0))
                            this.player.stop({y:1});
                    }else if(this.currentGDir.x == 0 || this.currentGDir.y == 0){
                        this.currentGDir = new Vector(1,1);
                    }

                    // apply gravity
                    this.player.addGrav(this.gravity, this.currentGDir);
                };

                // interface for moving the player
                this.movePlayer = function(quant){
                    this.player.move(quant);
                };

                // detects in which components the gravity is acting
                this.gravityDirection = function(){
                    var xDir = 0;
                    if(this.gravity.x > 0){
                        xDir = 1;
                    }else if(this.gravity.x < 0){
                        xDir = -1;
                    }
                    var yDir = 0;
                    if(this.gravity.y > 0){
                        yDir = 1;
                    }else if(this.gravity.y < 0){
                        yDir = -1;
                    }
                    return new Vector(xDir,yDir);
                };

                // detects what is the x direction of the player's ground, if it is in a ground
                // returns X ground direction (1 or -1), if not in a ground, returns 0
                this.playerGroundXDir = function(gravDir){
                    if(gravDir.x > 0){
                        if(this.x + this.width == this.player.position.x + this.player.size)
                           return 1;
                    }
                    if(gravDir.x < 0){
                        if(this.x == this.player.position.x)
                           return -1;
                    }
                    return 0;
                };

                // same for y
                this.playerGroundYDir = function(gravDir){
                    if(gravDir.y > 0){
                        if(this.y + this.height == this.player.position.y + this.player.size)
                           return 1;
                    }
                    if(gravDir.y < 0){
                        if(this.y == this.player.position.y)
                           return -1;
                    }
                    return 0;
                };
 
                // detects if player is in any ground, returns 1 or -1 for
                // x and y, indicating where the floor is on a given axis
                this.playerInGround = function(){
                    var gravDir = this.gravityDirection();

                    var groundDir = {
                        x: this.playerGroundXDir(gravDir),
                        y: this.playerGroundYDir(gravDir)
                    };
                    if(groundDir.x != 0 || groundDir.y != 0){
                        return true;
                    }

                    return false;
                };

                // detects if player is in any ceiling
                this.playerInCeiling = function(){
                    var jumpDir = this.gravityDirection();
                    jumpDir.multiplyBy(-1);

                    if(jumpDir.x > 0){
                        if(this.x + this.width == this.player.position.x + this.player.size)
                           return true;
                    }
                    if(jumpDir.x < 0){
                        if(this.x == this.player.position.x)
                           return true;
                    }
                    if(jumpDir.y > 0){
                        if(this.y + this.height == this.player.position.y + this.player.size)
                           return true;
                    }
                    if(jumpDir.y < 0){
                        if(this.y == this.player.position.y)
                           return true;
                    }
                    return false;
                };

                // detects if an entity is within the X range of the game
                this.entityInFieldX = function(sqentity){
                    var xMin = Math.min(sqentity.position.x, sqentity.position.x + sqentity.size),
                        xMax = Math.max(sqentity.position.x, sqentity.position.x + sqentity.size);
                    if(xMin > this.x && xMax < this.x + this.width){
                        return 0
                    }else if(xMin <= this.x){
                        return -1;
                    }else{
                        return 1;
                    }
                };

                // detects if an entity is within the Y range of the game
                this.entityInFieldY = function(sqentity){
                    var yMin = Math.min(sqentity.position.y, sqentity.position.y + sqentity.size),
                        yMax = Math.max(sqentity.position.y, sqentity.position.y + sqentity.size);
                    if(yMin > this.y && yMax < this.y + this.height){
                        return 0
                    }else if(yMin <= this.y){
                        return -1;
                    }else{
                        return 1;
                    }
                };
            }

            // implementation of a square shaped entity, on top of which
            // the player, enemies and points will be built
            function SQEntity(x,y,size){
                this.position = new Vector(x,y);
                this.size = size;

                // detects if this entity is colliding with another entity
                this.collidingWith = function(sqentity){
                    var minBoundThis = {
                            x: Math.min(this.x, this.x + this.size),
                            y: Math.min(this.y, this.y + this.size)
                        },
                        maxBoundThis = {
                            x: Math.max(this.x, this.x + this.size),
                            y: Math.max(this.y, this.y + this.size)
                        },
                        minBoundOther = {
                            x: Math.min(sqentity.x, sqentity.x + sqentity.size),
                            y: Math.min(sqentity.y, sqentity.y + sqentity.size)
                        },
                        maxBoundOther = {
                            x: Math.max(sqentity.x, sqentity.x + sqentity.size),
                            y: Math.max(sqentity.y, sqentity.y + sqentity.size)
                        },
                        intersectX = minBoundThis.x < maxBoundOther.x && maxBoundThis.x > minBoundOther.x,
                        intersectY = minBoundThis.y < maxBoundOther.y && maxBoundThis.y > minBoundOther.y;

                    if(intersectX && intersectY)
                        return true;
                    else
                        return false;
                };
            };


            function Obstacle(x,y,size){
                // inheritance
                this.prototype = SQEntity.prototype;
                
                SQEntity.call(this,x,y,size);

                // timestamp of the moment it was spawned
                this.birthTime = Date.now();

                // determines if obstacle should be rendered or not
                this.alive     = true;

                // if this variable is set to true, this obstacle
                // must stay where it is and never unspawn
                this.permanent = false;

                this.draw = function(ctx){
                    var lastFill   = ctx.fillStyle,
                        lastStroke = ctx.strokeStyle;
                    ctx.fillStyle = "#FFFFFF";
                    ctx.strokeStyle = "#000000";
                    ctx.fillRect(this.position.x, this.position.y, this.size, this.size);
                    ctx.fillStyle = lastFill;
                    ctx.strokeStyle = lastStroke;
                };
            };

            function ObstaclePool(){
                this.obstacles = [];
                this.obstSize  = 20;
                // maximum number os obstacle array
                this.obstLimit = 20;
                // lifespan of an obstacle, in miliseconds
                this.lifeSpan  = 20000;

                this.addObstacle = function(newObstacle){
                    newObstacle.permanent = true;
                    this.obstLimit++;
                    this.obstacles.push(newObstacle);
                };

                this.spawn = function(width, height, canvasX, canvasY){
                    // width and height refer to the field, not the canvas
                    // canvasX and canvasY refer to the field's offset to the canvas

                    // we take a random number between 0 and 3 to decide in which
                    // ground we will spawn it
                    var ground = Math.floor(Math.random()*4);
                    var x,y;

                    if(ground === 3){
                        // positive x
                        x = width - this.obstSize;
                        y = Math.floor(Math.random() * (height - this.obstSize));
                    }else if(ground === 2){
                        // negative x
                        x = 0;
                        y = Math.floor(Math.random() * (height - this.obstSize));
                    }else if(ground === 1){
                        // positive y
                        x = Math.floor(Math.random() * (width - this.obstSize));
                        y = height - this.obstSize;
                    }else if(ground === 0){
                        // negative y
                        x = Math.floor(Math.random() * (width - this.obstSize));
                        y = 0;
                    }
                    x += canvasX;
                    y += canvasY;
                    // adds an obstacle to the list if it's not full
                    // if it is, reuses an object
                    // only does any of that if there's enough space
                    if(this.obstacles.length < this.obstLimit){
                        this.obstacles.push(new Obstacle(x, y, this.obstSize));
                    }else{
                        var spawned = false;
                        for(var i = 0; i < this.obstLimit && !spawned; i++){
                            if(!this.obstacles[i].alive){
                                this.obstacles[i].position = new Vector(x,y);
                                this.obstacles[i].alive = true;
                                this.obstacles[i].birthTime = Date.now();
                                spawned = true;
                            }
                        }
                    }
                };

                this.update = function(){
                    for(var i = 0; i < this.obstacles.length; i++){
                        if(!this.obstacles[i].permanent && this.obstacles[i].alive &&
                            Date.now() - this.obstacles[i].birthTime > this.lifeSpan){
                            this.obstacles[i].alive = false;
                        }
                    }
                };

                this.render = function(ctx){
                    this.obstacles.forEach(function(obst){
                        if(obst.alive)
                            obst.draw(ctx);
                    });
                };

                this.reset = function(){
                    this.obstacles.forEach(function(obst){
                        obst.alive = false;
                        obst.permanent = false;
                    });
                };
            };

            // class for the player of the game
            function Player(x,y,size){
                // inheritance
                this.prototype = SQEntity.prototype;
                
                SQEntity.call(this,x,y,size);

                this.velocity  = new Vector(0,0);
                this.canJump = true;

                this.update = function(){
                    this.position.addTo(this.velocity);
                    // makes sure position is an integer
                    this.position.x = (this.position.x) | 0;
                    this.position.y = (this.position.y) | 0;
                };

                // accelerates the player by a vector
                this.accel = function(amount){
                    this.velocity.addTo(amount);
                };

                // moves the player by a vectorial amount
                this.move = function(amount){
                    this.position.addTo(amount);
                };

                // abstraction of a player jump
                this.jump = function(jumpSpeed, gravDir){
                    var quant = gravDir.multiply(-1) || new Vector(0,-1);
                    quant.multiplyBy(jumpSpeed);
                    if(this.canJump && quant){
                        this.canJump = false;
                        this.accel(quant);
                        self = this;
                        setTimeout(function(){self.canJump = true}, 300);
                    }
                };

                // applies gravity
                this.addGrav = function(gravity, dir){
                    var direction = dir || {x: 1, y: 1};
                    if(direction.x != 0 && direction.y != 0)
                        this.accel(gravity);
                    else if(direction.x != 0)
                        this.accel(gravity.xComponent());
                    else if(direction.y != 0)
                        this.accel(gravity.yComponent());

                };

                // stops player movement in a given direction
                this.stop = function(direction){
                    if(direction.x != 0)
                        this.velocity.x = 0;
                    if(direction.y != 0)
                        this.velocity.y = 0;
                };

                // draws the player in the correct positiom
                this.draw = function(ctx){
                    var lastFill   = ctx.fillStyle,
                        lastStroke = ctx.strokeStyle;
                    ctx.fillStyle = "#FF0000";
                    ctx.strokeStyle = "#000000";
                    // just to be really sure
                    var position = {
                        x : (this.position.x) | 0,
                        y : (this.position.y) | 0
                    };
                    ctx.fillRect(position.x, position.y, this.size, this.size);
                    ctx.fillStyle = lastFill;
                    ctx.strokeStyle = lastStroke;
                };
            };

            function main(){
                var canvas = document.getElementById("game");
                var f = new Game(canvas,canvas.width);
                f.startGame();
            };

            window.onload = main;
        </script>
    </head>
    <body>
        <!-- Caution! Canvas width and height must be the same -->
        <canvas width="600" height="600" id="game"></canvas>
    </body>
</html>